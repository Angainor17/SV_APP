package su.sv.commonarchitecture.domain.usecase

import kotlinx.coroutines.flow.Flow

/**
 * Объединение юзкейсов, от которых нужно наследоваться при разработке.
 *
 * Принцип такой - есть юзкейсы, которые не могут вернуть ошибку (без суффмкса Result)
 * и есть юзкейсы, который могут возвращать ошибку (с суффиксом Result).
 * Такое делеление нужно, чтобы дать вызывающему методу точный контракт, как ведет себя текущий юзкейс, кидает ли он ошибку.
 *
 * Кроме этого, все юзкейсы параметризированы. Если у вашего юзкейса нет входных/выходных параметров, то используйте [Unit]
 * Альтернатива Unit'y - сделать большой набор юзкейсов со всеми комбинациями входных и выходных параметров.
 * Совместным решением команды быд принял подход, при котором число базовых юзкейсов минимизировано.
 */
sealed interface UseCases {

    /** Операция, которая не может завершиться ошибкой */
    interface Unary<Params, Result> : UseCases {
        suspend fun execute(params: Params): Result
    }

    /** Операция, которая может завершиться какой-либо ошибкой. Если имеются особые ошибки, на которые МП должно особым
     * образом реагировать, то в документации к юзкейсу в разделе return нужно прикладывать, какие ошибки бывают.
     * Ошибки должны наследоваться от [Throwable] */
    interface UnaryResult<Params, Result : Any> : UseCases {
        suspend fun execute(params: Params): kotlin.Result<Result>
    }

    /** Юзкейс, который поставляет данные в виде [Flow] и не кидает ошибку */
    interface Stream<Params, Result> : UseCases {
        fun execute(params: Params): Flow<Result>
    }

    /** Юзкейс, который поставляет данные в виде [Flow], но при этом может кинуть ошибку.
     * Если имеются особые ошибки, на которые МП должно особым образом реагировать, то в документации к юзкейсу в
     * разделе return нужно прикладывать, какие ошибки бывают.
     * Ошибки должны наследоваться от [Throwable]  */
    interface StreamResult<Params, Result> : UseCases {
        fun execute(params: Params): Flow<kotlin.Result<Result>>
    }
}
